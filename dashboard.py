# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_t0vtW_spI_WklrrOJm1J5tnO_K3m925
"""

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import st_folium
from folium.plugins import MarkerCluster, HeatMap
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
import base64
from io import BytesIO
import datetime

# ---------- Images ----------
banner_path = r'C:\Users\ntkr3\Infosys Project\enviroscan_banner.png'
sidebar_img_path = r'C:\Users\ntkr3\Infosys Project\side_img.webp'  # match to your actual file name/extension

# Banner image
banner = Image.open(banner_path)
buffered = BytesIO()
banner.save(buffered, format="PNG")
img_str = base64.b64encode(buffered.getvalue()).decode()

# Sidebar image (.webp handled via PIL, then converted to png for browser display)
side_image = Image.open(sidebar_img_path)
side_buffered = BytesIO()
side_image.save(side_buffered, format="PNG")
side_img_str = base64.b64encode(side_buffered.getvalue()).decode()

# ---------- CSS ----------
st.markdown("""
<style>
.stApp {
    background: linear-gradient(135deg, #e0f7fa 0%, #fce4ec 100%);
}
.title-container {
    display: flex;
    align-items: center;
    background: linear-gradient(90deg,#4facfe 0%,#00f2fe 100%);
    border-radius: 14px;
    padding: 15px 25px;
    margin-bottom: 1.5rem;
    color: white;
    box-shadow: 0 8px 30px rgba(0,0,0,0.3);
}
.title-container img {
    height: 120px;
    width: auto;
    border-radius: 12px;
    margin-right: 25px;
    filter: brightness(0.9);
}
.title-container h1 {
    font-size: 2.7rem;
    font-weight: 900;
    margin: 0;
    text-shadow: 2px 2px 7px rgba(0,0,0,0.7);
}
[data-testid="stSidebar"] > div:first-child {
    background: #121212;
    color: #eee;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.8);
}
.sidebar-image {
    width: 100%;
    margin-bottom: 14px;
    border-radius: 14px;
    box-shadow: 0 3px 8px #2222225f;
}
.sidebar-card {
    background: rgba(30,30,40,0.96);
    padding: 18px 20px;
    border-radius: 16px;
    box-shadow: 0 6px 14px rgba(0,0,0,0.65);
    margin-top: 12px;
}
label[for^='Select a city'] {
    color: #fcbf49 !important;
    font-weight: 900;
    font-size: 1.1rem;
}
div[data-baseweb="select"] > div {
    color: #fff !important;
    background-color: #212529 !important;
    font-weight: bold !important;
}
div[role="listbox"] span {
    color: #f5e050 !important;
    background-color: #24292e !important;
    font-weight: bold !important;
    font-size: 1.1rem;
}
div.stButton > button:first-child {
    background-color: #00796b;
    color: white;
    font-weight: 600;
    border-radius: 12px;
    padding: 0.6rem 1.5rem;
    box-shadow: 2px 2px 6px rgba(0,121,107,0.5);
    transition: background-color 0.3s ease;
    user-select: none;
}
div.stButton > button:first-child:hover {
    background-color: #004d40;
    cursor: pointer;
}
.stylish-btn-row { display: flex; justify-content: center; gap: 34px; margin-bottom: 24px;}
.stylish-btn {
    background: linear-gradient(90deg, #4facfe 0%, #fcb045 100%);
    color: white;
    font-size: 1.23rem;
    font-weight: 800;
    border: none;
    border-radius: 16px;
    padding: 15px 38px;
    margin: 0 2px;
    box-shadow: 0 4px 18px #22222220;
    transition: background 0.3s, color 0.3s, transform 0.2s;
    cursor: pointer;
}
.stylish-btn:hover {
    background: linear-gradient(90deg, #fcb045 0%, #4facfe 100%);
    color: #222;
    transform: scale(1.08);
}
</style>
""", unsafe_allow_html=True)

# --------------- Data ---------------
@st.cache_data
def load_data():
    df = pd.read_csv(r'C:\Users\ntkr3\Infosys Project\processed_pollution_data.csv')
    df['Timestamp'] = pd.to_datetime(df['Timestamp'])
    return df
df = load_data()

# -------- Banner/Title
st.markdown(
    f"""
    <div class="title-container">
        <img src="data:image/png;base64,{img_str}" alt="EnviroScan Banner"/>
        <h1>EnviroScan: Andhra Pradesh Pollution Dashboard</h1>
    </div>
    """,
    unsafe_allow_html=True
)

# ---------- Sidebar ----------
with st.sidebar:
    st.markdown(f'<img class="sidebar-image" src="data:image/png;base64,{side_img_str}">', unsafe_allow_html=True)
    st.markdown('<div class="sidebar-card">', unsafe_allow_html=True)
    about_expander = st.expander("About")
    with about_expander:
        st.markdown("""
**Project Overview:**
EnviroScan is an AI-powered dashboard to analyze, visualize, and forecast air pollution across Andhra Pradesh cities.
**Key Features:**
- Pollution trends
- Real-time, historical, and forecast AQI
- Source distribution
- Maps by city
- SMS alerts
- Fast & beautiful UI
        """)
    st.header("Filters")
    cities = df['city'].unique().tolist()
    selected_city = st.selectbox("Select a city:", cities)
    start_date = st.date_input("Start date", value=df['Timestamp'].min().date(),
                               min_value=df['Timestamp'].min().date(),
                               max_value=df['Timestamp'].max().date(),
                               key="start_date")
    end_date = st.date_input("End date", value=df['Timestamp'].max().date(),
                             min_value=df['Timestamp'].min().date(),
                             max_value=df['Timestamp'].max().date(),
                             key="end_date")
    btn_select = st.button("Apply City Filter")
    st.header("SMS Alerts")
    phone_number = st.text_input("Phone number (+CountryCode)", "")
    enable_sms = st.checkbox("Enable SMS alerts")
    st.markdown('</div>', unsafe_allow_html=True)

if btn_select:
    df_filtered = df[
        (df['city'] == selected_city) &
        (df['Timestamp'].dt.date >= start_date) &
        (df['Timestamp'].dt.date <= end_date)
    ]
else:
    df_filtered = df[
        (df['Timestamp'].dt.date >= start_date) &
        (df['Timestamp'].dt.date <= end_date)
    ]

st.write(f"Records selected: {len(df_filtered)}")

# --- Stylish Section Navigation Buttons ---
if "section" not in st.session_state:
    st.session_state["section"] = "Pollution Trends"

st.markdown('<div class="stylish-btn-row">', unsafe_allow_html=True)
col1, col2, col3, col4 = st.columns(4)
with col1:
    if st.button("Pollution Trends", key="trend_btn"):
        st.session_state["section"] = "Pollution Trends"
with col2:
    if st.button("Source Distribution", key="source_btn"):
        st.session_state["section"] = "Source Distribution"
with col3:
    if st.button("Map & Alerts", key="map_btn"):
        st.session_state["section"] = "Map & Alerts"
with col4:
    if st.button("Future Prediction", key="future_btn"):
        st.session_state["section"] = "Future Prediction"
st.markdown('</div>', unsafe_allow_html=True)

section = st.session_state["section"]

# --- Main Sections ---
if section == "Pollution Trends":
    pollutants = ['PM2.5', 'PM10', 'NO2', 'SO2', 'CO', 'Ozone']
    pollutant = st.selectbox("Select pollutant for trend:", pollutants)
    trend_data = df_filtered[df_filtered['city'] == selected_city].groupby('Timestamp')[pollutant].mean().reset_index()
    fig, ax = plt.subplots(figsize=(10,4))
    ax.plot(trend_data['Timestamp'], trend_data[pollutant], marker='o', linestyle='-', color='#00796b')
    ax.set_title(f'{pollutant} Pollution Trend in {selected_city}')
    ax.set_xlabel('Date and Time')
    ax.set_ylabel(pollutant)
    ax.grid(True, linestyle='--', alpha=0.6)
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    st.pyplot(fig)

elif section == "Source Distribution":
    sources = df_filtered[df_filtered['city'] == selected_city]['source'].value_counts()
    labels = sources.index.tolist()
    sizes = sources.values.tolist()
    colors = ['#0288d1', '#fb8c00', '#43a047', '#e91e63', '#8bc34a', '#607d8b']
    explode = [0.08 if size < 0.2 * sum(sizes) else 0 for size in sizes]
    fig, ax = plt.subplots(figsize=(7, 7))
    wedges, texts, autotexts = ax.pie(
        sizes, labels=labels, autopct='%1.1f%%',
        startangle=90, explode=explode, colors=colors[:len(labels)],
        textprops={'fontsize': 12}, pctdistance=0.82
    )
    for i, txt in enumerate(texts):
        if sizes[i] < 0.15 * sum(sizes):
            txt.set_position((1.3 * txt.get_position()[0], 1.3 * txt.get_position()[1]))
    plt.title(f'Source Distribution in {selected_city}')
    ax.axis('equal')
    plt.legend(labels, loc='center left', bbox_to_anchor=(1, 0.5))
    st.pyplot(fig)

elif section == "Map & Alerts":
    st.subheader(f"Map & Alerts for {selected_city} (all pollutants)")
    selected_city_data = df_filtered[df_filtered['city'] == selected_city].copy()
    if not selected_city_data.empty:
        m = folium.Map(location=[selected_city_data['latitude'].mean(), selected_city_data['longitude'].mean()], zoom_start=11)
        marker_cluster = MarkerCluster().add_to(m)
        for _, row in selected_city_data.iterrows():
            popup = "<br>".join(
                [f"{poll}: {row[poll]:.1f}" for poll in ['PM2.5','PM10','NO2','SO2','CO','Ozone'] if poll in row]
            )
            folium.CircleMarker(
                location=[row['latitude'], row['longitude']],
                radius=7,
                color="#009688",
                fill=True,
                fill_opacity=0.75,
                popup=f"{row['city']}<br>{popup}<br>Source: {row['source']}"
            ).add_to(marker_cluster)
        avg_pollutant = selected_city_data[['latitude','longitude','PM2.5','PM10','NO2','SO2','CO','Ozone']].dropna()
        heat_data = [
            [row['latitude'], row['longitude'], np.mean([row[p] for p in ['PM2.5','PM10','NO2','SO2','CO','Ozone']])]
            for _, row in avg_pollutant.iterrows()
        ]
        if heat_data:
            HeatMap(heat_data, radius=12, blur=16).add_to(m)
        st_folium(m, width=800, height=500)
    else:
        st.info("No data available for selected city.")

elif section == "Future Prediction":
    st.subheader("Future AQI Prediction")
    st.write("Select a future date and pollutant to view forecasted AQI and its category.")
    pollutants = ['PM2.5', 'PM10', 'NO2', 'SO2', 'CO', 'Ozone']
    pred_pollutant = st.selectbox("Select pollutant:", pollutants, key="prediction_pollutant")
    min_pred_date = max(df['Timestamp'].dt.date.max(), datetime.date.today())
    max_pred_date = min_pred_date + datetime.timedelta(days=90)
    future_date = st.date_input("Select future date for prediction", value=min_pred_date, min_value=min_pred_date, max_value=max_pred_date, key="future_date_predict")
    predict_button = st.button("Predict AQI")
    if predict_button:
        pred_df = df[(df['city'] == selected_city)]
        if not pred_df.empty:
            lookback = 5
            pred_trend = pred_df.groupby('Timestamp')[pred_pollutant].mean().reset_index()
            last_values = pred_trend[pred_pollutant].tail(lookback)
            predicted_value = last_values.mean() if not last_values.empty else None
            def get_aqi_category(val, pollutant):
                if pollutant in ['PM2.5', 'PM10']:
                    if val <= 50: return "Good"
                    elif val <= 100: return "Satisfactory"
                    elif val <= 250: return "Moderate"
                    elif val <= 350: return "Poor"
                    else: return "Very Poor"
                elif pollutant == "NO2":
                    if val <= 40: return "Good"
                    elif val <= 80: return "Satisfactory"
                    elif val <= 180: return "Moderate"
                    elif val <= 280: return "Poor"
                    else: return "Very Poor"
                elif pollutant == "SO2":
                    if val <= 20: return "Good"
                    elif val <= 40: return "Satisfactory"
                    elif val <= 80: return "Moderate"
                    elif val <= 380: return "Poor"
                    else: return "Very Poor"
                elif pollutant == "CO":
                    if val <= 1: return "Good"
                    elif val <= 2: return "Satisfactory"
                    elif val <= 10: return "Moderate"
                    elif val <= 17: return "Poor"
                    else: return "Very Poor"
                elif pollutant == "Ozone":
                    if val <= 50: return "Good"
                    elif val <= 100: return "Satisfactory"
                    elif val <= 168: return "Moderate"
                    elif val <= 208: return "Poor"
                    else: return "Very Poor"
                return "Unknown"
            aqi_category = get_aqi_category(predicted_value, pred_pollutant) if predicted_value is not None else "Unknown"
            st.success(f"⚡ Forecasted AQI: {predicted_value:.2f} ({aqi_category})")
            fig, ax = plt.subplots(figsize=(7,4))
            ax.scatter([future_date], [predicted_value], color='#f48c06', s=200, label='Prediction')
            ax.set_title(f'Future Prediction for {pred_pollutant} in {selected_city}')
            ax.set_xlabel('Date')
            ax.set_ylabel(pred_pollutant)
            ax.grid(True, linestyle='--', alpha=0.5)
            plt.legend()
            plt.tight_layout()
            st.pyplot(fig)
        else:
            st.warning("No data for predictions.")

# ----- Download Button -----
csv_bytes = df_filtered.to_csv(index=False).encode('utf-8')
st.download_button(
    label='Download filtered data as CSV',
    data=csv_bytes,
    file_name='pollution_report.csv',
    mime='text/csv',
)